---
id: 789
title: Bloggin from GitHub 1
subtitle: Part 1
author: Dmitry "Oda" Vikhorev
date: 20230910
timeToRead: 3 min
version: 0.1
tags: ["GitHub", ".mdx"]
---

<TLDR>
I want to streamline my blogging. 
Because if I don't there won't be any üìù

End goal:

‚úçÔ∏è Write this as a Markdown file on GitHub

‚úÖ Click commit

‚ú® Have it magically apear online, looking all nice and pretty. 

ü§´ way nicer and prettier than a simple Markdown would allow though
</TLDR>

## Problem
Blogging is not easy. And it takes me too long to write a post in JSX.
I want to make the production (writing and publishing) as simple as possible to focus on the content. 
<PB4/>
Ideally, any time I have something I'd like to put in writing,
I need some quick and easy way to write and publish it. Which I didn't until recently.
<PB4/>

## Solution
1. Add .mdx support to Next.js.
2. Use common .mdx template to write posts.
3. Use custom components to format text.
4. Once done, <Code>git push</Code> to Heroku.
<PB8/>
# Let's go

## Old setup
My first setup looked like this: 
**a)** Create posts.tsx file that exports an array of Posts, each Post being
<PB4/>
```typescript
 type Post = {
  id: number,
  slug: string,
  header: string,
  subheader: string,
  dateCreated: [number, number, number],
  author: string,
  timeToRead: string,
  timeToThink: string,
  ersion: string,
  tags: string[],
  body: React.Node
}
``` 
<PB8/>
**b)** Then any time I wanted to write a new blogpost, I'd copy this skeleton, *write the content as a jsx body* and add the result to the exported array.
<PB4/>
```typescript
 [
  ...posts,
  {
  id: 1,
  slug: "slug",
  header: "header",
  subheader: "subheader",
  dateCreated: [2022, 2, 10],
  author: "author",
  timeToRead: "timeToRead",
  timeToThink: "timeToThink",
  ersion: "0.0.1",
  tags: [],
  body:  <div> hey, let's spend too much time setting things up? </div>
}
```
<PB4/>
**c)** Then I would not want to do it ever again. 
<PB4/>

### write the content as a jsx body
It is this part that made me cringe and find excuses not to write the next blogpost every time I had an inclination to do so. 
<PB8/>

## New setup
So I decided to invest a bit of time and do the setup properly. 
1. I will write Markdown + use custom tsx elements in .mdx files
2. Store them locally (for now) and 
3. Have GitHub deploy to Heroku every time I push into main branch. 
<PB4/>
Let's see how this works.
<PB8/>

### Markdown
As I wanted to write simple human readable text, with as little decorations as possible I chose to use <WebLink href="https://www.markdownguide.org/">Markdown</WebLink>. It is never a bad idea to level up your Markdown skills, is it. 
<PB8/>

### .mdx files
However, instead of writing pure .md files, I decided to go with <WebLink href="https://mdxjs.com">MDX</WebLink>. In the nutshell, MDX alows mixing JSX/TSX syntax in one file.
<PB4/>
And since I am eye ball deep in Next.js, this <WebLink html="https://nextjs.org/docs/pages/building-your-application/configuring/mdx">rtfm</WebLink> also helped a lot. 
<PB8/>

## Writing .mdx post

## Loading .mdx post
```typescript
/**
 * Loads .mdx files and parses front-matter 
 */
async function loadPosts(pathToPosts: string, fs: any): Promise<Post[]> {
  const paths = fs.readdirSync(pathToPosts)
  const posts = 
    paths
    .map((path: string) => {
      const mdx = fs.readFileSync(Path.join(pathToPosts, path))
      // data is blog post's metadata
      // content is blog posts's content
      let {content, data} = matter(mdx)
      data = {filePath: path, ...data}
      return {content, data, filePath: path}
    })
  return posts
}
```
<PB8/>

## SSR Blog with .mdx files
I'm using the Next.js `Page Router`, so when `.../blog/posts/nice-story` path is requested, Next.js calls a dynamic route where the post (if it exists) will be displayed (or 404). 
```
/..
|-- ..
|-- pages
    |-- blog
        |-- posts
            |-- [slug].tsx  <- dynamic route
```

## [slug].tsx 
This file is returning <Code>PostPage</Code> SSR component like so:
```typescript
export default function PostPage({ currentPost: {source, data}, previousPost, nextPost}: InferGetStaticPropsType<typeof getStaticProps>) {
  return (
    <Layout>
      <Header 
        title={data.title}
        subtitle={data.subtitle}
        author={data.author}
        timeToRead={data.timeToRead}
        version={data.version}
        date={data.date}
        />
      {data.description && <p className="description">{data.description}</p>}
      <main>
        <MDXRemote {...source} components={components as MDXComponents}/>
      </main>
      <BlogNavigation previousPost={previousPost} nextPost={nextPost}/>
    </Layout>
  )
}
```
<PB4/>

<Code>currentPost</Code> is where MDX magic comes from.
Let's see how we obtain it. 

## Getting .mdx file as data into PostPage
Since we are in SSR and have everything stored locally, we can generate all paths and load contents with
<PB4/>
```typescript
export const getStaticPaths = async () => {
  const paths = postFilePaths
    // Remove file extensions for page paths
    .map((path) => path.replace(/\.mdx?$/, ''))
    // Map the path into the static paths object required by Next.js
    .map((slug) => ({ params: { slug } }))

  return {
    paths,
    fallback: false,
  }
}
```
<PB4/>
and
<PB4/>
```typescript
export const getStaticProps: GetStaticProps<{
  currentPost: { source: MDXSource; data: frontMatterData };
  previousPost: Post | null;
  nextPost: Post | null;
}> = async ({ params }) => {
  const posts = await loadPosts(POSTS_PATH, fs).then(sortPosts);
  const [currentPost] = posts.filter(
    ({ filePath }) => filePath === `${params?.slug}.mdx`
  );
  const { content, data } = matter(currentPost);

  const navigation = calculateNavigation(currentPost, posts);
  const mdxSource = await serialize(content, {
    mdxOptions: {
      remarkPlugins: [],
      rehypePlugins: [[rehypePrettyCode, codeHighlightOptions]],
    },
    scope: data,
  });

  return {
    props: {
      currentPost: {
        source: mdxSource,
        data,
      },
      ...navigation,
    },
  };
};
```


This is a SSR component that handles loading of the .mdx posts and turning them into a `Post[]`

## MDX plugins
https://github.com/remarkjs/remark-gfm
https://nextjs.org/docs/pages/building-your-application/configuring/mdx#custom-elements

## How do I render .mdx?
There are two ways to load .mdx files in Next.js: locally and remotely. 
I chose to go with the second as in future I plan to store files on S3 or in some database. For now they all reside in <Code>my-blog/posts</Code> directory. 
<PB8/>
UNFINISHED üéÉ

## Keep metadata in .mdx
One important thing for me was the ability to keep all associated metadata in the same .mdx file. It looks like this:
<PB4/>
```
// from here 
---
id: 789
title: Bloggin from GitHub 1
subtitle: Part 1
author: Dmitry "Oda" Vikhorev
date: 20230910
timeToRead: 3 min
version: 0.1
tags: ["GitHub", ".mdx"]
---
// to here is called "front-matter"

// all actual blog content goes here ...
```
<PB4/>

The trick is to process the .mdx file that contains *front-matter* with <WebLink href="https://www.npmjs.com/package/gray-matter">grey-matter</WebLink>, a package that can parse a string into an object.  
<PB4/> 

At the moment I figured out how to do it having read in .mdx as with
```typescript

```